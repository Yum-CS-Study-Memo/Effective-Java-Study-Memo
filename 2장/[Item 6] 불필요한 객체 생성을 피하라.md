# Effective Java Item 6 - 불필요한 객체 생성을 피하라

## 📌 핵심 요약

똑같은 기능의 객체를 매번 새로 만들지 말고, **하나를 재사용**하는 편이 낫다. 불변 객체는 언제든 재사용할 수 있다.

---

## 1. 어댑터(뷰) 패턴과 객체 재사용

### 어댑터(뷰)란?

어댑터는 실제 작업을 **뒷단 객체에 위임**하고, 자신은 **제2의 인터페이스 역할**만 해주는 객체다. 어댑터를 뷰(view)라고도 부른다.

> **비유**: TV 리모컨을 생각하면 된다. 리모컨 자체는 아무 기능이 없고, 버튼을 누르면 **TV가 실제 일을 한다**. 리모컨은 TV를 조작하기 편하게 해주는 중간 도구일 뿐이다.

- **뒷단 객체** = TV (실제로 일하는 녀석)
- **어댑터** = 리모컨 (뒷단 객체를 편하게 쓸 수 있게 해주는 중간 역할)

### 왜 어댑터는 하나만 만들면 충분할까?

어댑터는 뒷단 객체 **외에는 관리할 상태(데이터)가 없다**. 따라서 뒷단 객체 하나당 어댑터 하나씩만 만들면 충분하다.

### 예시: `Map.keySet()`

`Map` 인터페이스의 `keySet()` 메서드는 Map 객체 안의 키 전부를 담은 **Set 뷰**를 반환한다.

```java
Map map = new HashMap<>();
map.put("사과", 1000);
map.put("바나나", 2000);

Set keys1 = map.keySet();  // 뷰 1
Set keys2 = map.keySet();  // 뷰 2

// keys1과 keys2는 같은 Map을 보는 같은 뷰!

map.put("포도", 3000);  // 원본 Map에 추가

// keys1에도 "포도"가 보인다
// keys2에도 "포도"가 보인다
// → 둘 다 같은 Map을 들여다보는 "창문"이기 때문
```

> **비유**: 집에 창문이 3개 있어도, 보이는 풍경은 똑같다. 밖에 나무를 심으면 모든 창문에서 그 나무가 보인다. 창문은 바깥을 보여주는 통로일 뿐이니까.

```
┌──────────────────────────┐
│      Map (원본 데이터)       │
│  "사과" → 1000             │
│  "바나나" → 2000            │
│  "포도" → 3000             │
└──────────┬───────────────┘
           │
     ┌─────┴─────┐
     │  keySet()  │  ← "창문(뷰)"
     │  뷰(View)   │     원본을 들여다볼 뿐
     └───────────┘
```

#### 핵심 포인트

- `keySet()`을 호출할 때마다 새로운 Set이 만들어지리라 생각할 수 있지만, 실제로는 **매번 같은 Set 인스턴스를 반환할 수도 있다**
- 반환된 Set 인스턴스가 일반적으로 가변이더라도, 반환된 인스턴스들은 **기능적으로 모두 똑같다**
- 반환한 객체 중 하나를 수정하면 **다른 모든 객체가 따라서 바뀐다** (모두가 똑같은 Map 인스턴스를 대변하기 때문)
- `keySet()`이 뷰 객체를 여러 개 만들어도 상관은 없지만, **그럴 필요도 없고 이득도 없다**

---

## 2. 오토박싱(Auto Boxing)의 함정

### 기본 타입 vs 박싱된 기본 타입

| 기본 타입 (primitive) | 박싱된 타입 (wrapper) |
|---|---|
| `long` (소문자) | `Long` (대문자) |
| `int` (소문자) | `Integer` (대문자) |

> **비유**: 기본 타입 `long`은 **알몸의 숫자** (가볍고 빠르다), 박싱된 타입 `Long`은 **숫자를 선물 상자에 포장한 것** (상자(객체)를 만드는 비용이 든다).

### 오토박싱(Auto Boxing)이란?

기본 타입과 박싱된 기본 타입을 프로그래머가 섞어 쓸 때, Java가 **자동으로 상호 변환**해주는 기술이다.

```java
long a = 5;      // 기본 타입
Long b = a;      // 자동으로 Long 객체에 포장됨 → 오토박싱
```

오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, **완전히 없애주는 것은 아니다**.

### 끔찍한 예시 코드

```java
// 코드 6-3: 끔찍이 느리다! 객체가 만들어지는 위치를 찾았는가?
private static long sum() {
    Long sum = 0L;  // ⚠️ Long(대문자)으로 선언 → 문제의 원인!
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;   // 매번 오토박싱 발생!
    return sum;
}
```

#### 무슨 일이 벌어지는가?

`sum += i` 실행 시:

1. `sum`(Long 객체)의 상자를 열어서 숫자를 꺼낸다 (언박싱)
2. `i`(long 기본 타입)와 더한다
3. 결과를 **다시 새 Long 상자에 넣는다** (오토박싱) ← 🔥 새 객체 생성!

이 과정이 약 **21억 번**(2³¹) 반복되므로, 불필요한 Long 인스턴스가 약 **2³¹개** 만들어진다.

```
❌ Long + long = 매번 새 상자 포장 (21억 번)
   📦 → 🔓 → ➕ → 📦 → 🔓 → ➕ → 📦 ... (21억 번 반복)

✅ long + long = 그냥 숫자끼리 더하기
   5 + 3 = 8. 끝. 빠름.
```

#### 해결 방법: 딱 한 글자 수정

```java
// ❌ 느린 코드 (6.3초)
Long sum = 0L;   // 대문자 Long → 객체

// ✅ 빠른 코드 (0.59초)
long sum = 0L;   // 소문자 long → 기본 타입
```

대문자 `L`ong을 소문자 `l`ong으로 바꿨을 뿐인데, **6.3초 → 0.59초**로 약 10배 이상 빨라진다.

### 교훈

- **박싱된 기본 타입보다는 기본 타입을 사용하라**
- **의도치 않은 오토박싱이 숨어들지 않도록 주의하라**

---

## 3. 주의사항

> ⚠️ 이번 아이템을 **"객체 생성은 비싸니 피해야 한다"**로 오해하면 안 된다.

- 요즘 JVM에서 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일은 크게 부담되지 않는다
- 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것은 일반적으로 좋은 일이다
- 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 자신만의 객체 풀(pool)을 만들지 말라
- **불필요한** 객체 생성을 피하자는 것이지, 객체 생성 자체를 기피하라는 뜻이 아니다

---

## 📝 핵심 정리

| 주제 | 핵심 내용 |
|---|---|
| **어댑터(뷰)** | 뒷단 객체 외에 관리할 상태가 없으므로 뒷단 객체 하나당 어댑터 하나면 충분 |
| **Map.keySet()** | 매번 새 Set을 만드는 게 아니라 같은 뷰를 반환 → 여러 개 만들 필요 없음 |
| **오토박싱** | `Long`과 `long`의 혼용으로 불필요한 객체가 대량 생성될 수 있음 |
| **교훈** | 기본 타입 사용을 우선하고, 의도치 않은 오토박싱을 경계하라 |